<!DOCTYPE html>
<html lang="en">

<!-- 本项目最大的坑：ctx.translate是可叠加的 -->
<!-- 虽然HTMLjs不能修改、保存文件，但是我可以把修改后的数据存入img.src中，然后就能更新数据并一直保有了鸭 -->

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>canvasSVG</title>
    <link href="/t.css" rel="stylesheet" type="text/css" /> 
</head>

<body>
    <div id="image"></div>
    <div id="gif"></div>

    <div id="ss" style="font-size: 10px;color: red;top: 2px;left: 20px;display: block;position: absolute"></div>

    <span id="backDrawCSS">
        <img src="back_draw.svg" class="backDrawImg" onclick="backDraw()"/>
        <span class="backDrawP">重写</span>
    </span>
    <span id="reRenderCSS">
        <img src="refresh.svg" class="reRenderImg" onclick="reRender()"/>
        <span class="reRenderP">重新生成</span>
    </span>    
    <span id="backInputCSS">
        <img src="back_draw.svg" class="backInputImg" onclick="backInput()"/>
        <span class="backInputP">重新输入标签</span>
    </span>
    <span id="returnHomeCSS">
        <img src="return_home.svg" class="returnHomeImg" onclick="returnHome()"/>
        <span class="returnHomeP">首页</span>
    </span>
    <span id="returnDrawCSS">
        <img src="return_draw.svg" class="returnDrawImg" onclick="returnDraw()"/>
        <span class="returnDrawP">重写</span>
    </span>

    <canvas width="1600" height="1200" class="myCanvas" id="canvas"></canvas>
    <button id="clearbtn" class="bbtn" onclick="clearDraw()">清除</button>
    <button id="selectbtn" class="bbtn" onclick="slectedOver()">选择完毕</button>
    <button id="dwnbtn" class="bbtn" onclick="download()">下载</button>

    <!-- 隐藏的输入框，等待显示 -->
    <div id="container">
        <input class="inputBar" type="text" placeholder="例如[丝]，可输入：飘扬的丝带" />
        <button alt="" class="nextBtn" onclick="hideInput()">下一步</button>
    </div>

    <div id="qrcode"></div>
</body>


<script src="https://cdn.bootcss.com/FileSaver.js/1.3.8/FileSaver.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
<script src="https://unpkg.com/axios/dist/axios.min.js"></script>
<script src="https://zxpsuper.github.io/Demo/qrcode/qrcode-dev.js"></script>

<!-- 欢迎页部分 -->
<script>
    var phase=0;
    var canvasW = 1200;
    var canvasH = 600;
    //设置axios请求公共头
    axios.defaults.baseURL = 'http://139.196.197.42:8080'

    // 页面加载完成后执行操作
    window.onload = function() {
        //展示军火
        showWelcomeElement()

        document.body.addEventListener("dblclick", showGif);
    };


    // 显示GIF
    function showGif() {
        var gifDiv = document.getElementById("gif");
        var gifImg = document.createElement("img");
        gifImg.src = "welcome.gif";
        gifImg.alt = "GIF animation";
        gifImg.style.width = "100%";
        gifImg.style.height = "100%";
        gifDiv.innerHTML = "";
        gifDiv.appendChild(gifImg);
        gifDiv.style.display = "block";

        //更新画布长宽为铺满屏幕
        // 获取当前屏幕宽高
        var screenWidth = window.innerWidth;
        var screenHeight = window.innerHeight;
        // 获取canvas元素
        var canvas = document.getElementById("canvas");
        // 更新canvas元素的宽高
        canvas.width = screenWidth;
        canvas.height = screenHeight;
        
        const canvas_content = canvas.getBoundingClientRect()//获取画布的大小
        canvasW=canvas_content.width
        canvasH=canvas_content.height

        // 停止GIF播放
        setTimeout(function() {
            coverWelcomeElement()
            //执行完毕后自动删除自己，
            //避免后面的phase中会突然来一个开屏页，或者最后一页点击“首页”回来时自动展示动画
            document.body.removeEventListener("click", showGif);  
            console.log("111行")
            writeOnload()
        }, 4500); // 4.5秒后停止播放
    }

    function showWelcomeElement(){
        console.log("设置全屏居中欢迎页图片")
        var imageDiv = document.getElementById("image");
        imageDiv.style.backgroundImage = "url('initial.jpg')";
        imageDiv.style.display="block";
    }

    function coverWelcomeElement(){
        console.log("不显示欢迎页")
        var imageDiv = document.getElementById("image");
        imageDiv.style.display="none";
        var gifDiv = document.getElementById("gif");
        document.body.removeEventListener("click", showGif);
        gifDiv.style.display="none"
    }

    //检查phase以设置canvas背景
    function checkPhase(){
        switch (phase) {
          case 1:
            canvas.style.backgroundImage = 'url(' + "'bk1.png'" + ')';
            var clearbtn = document.getElementById('clearbtn');
            clearbtn.style.right=canvasW/10+'px';
            clearbtn.style.bottom=canvasH/13+'px';
            clearbtn.style.width=canvasW/11+'px';
            clearbtn.style.height=canvasH/12+"px";
            clearbtn.style.display = "block";
            break;
          case 2:
            canvas.style.backgroundImage = 'url(' + "'bk2.png'" + ')';
            //不显示“清除”按钮
            var clearbtn = document.getElementById('clearbtn');
            clearbtn.style.display = "none";
            //显示“选择完毕”按钮
            var selectbtn = document.getElementById('selectbtn');
            selectbtn.style.right=canvasW/10+'px';
            selectbtn.style.bottom=canvasH/13+'px';
            selectbtn.style.width=canvasW/8+'px';
            selectbtn.style.height=canvasH/12+"px";
            selectbtn.style.display = "block";
            //显示“重写”按钮
            var backDrawCSS=document.getElementById('backDrawCSS')
            backDrawCSS.style.display="block"
            break;
          case 3:
            canvas.style.backgroundImage = 'url(' + "'bk3.png'" + ')';
            //不显示“重写”按钮
            var backDrawCSS=document.getElementById('backDrawCSS')
            backDrawCSS.style.display="none"
            //不显示“选择完毕”按钮
            var selectbtn = document.getElementById('selectbtn');
            selectbtn.style.display = "none";
            break;
          case 4:
            canvas.style.backgroundImage = 'url(' + "'bk4.png'" + ')';
            //显示“下载”按钮
            var dwnbtn = document.getElementById('dwnbtn');
            dwnbtn.style.right=canvasW/10+'px';
            dwnbtn.style.bottom=canvasH/13+'px';
            dwnbtn.style.width=canvasW/11+'px';
            dwnbtn.style.height=canvasH/12+"px";
            dwnbtn.style.display = "block";
            //显示“重新生成”按钮
            var reRenderCSS=document.getElementById('reRenderCSS')
            reRenderCSS.style.display = "block";  
            //显示“重新输入标签”按钮
            var backInputCSS=document.getElementById('backInputCSS')
            backInputCSS.style.left="200px";
            backInputCSS.style.display = "block";            
            break;
          case 5:
            canvas.style.backgroundImage = 'url(' + "'bk5.png'" + ')';
            //不显示“重新输入标签”按钮
            var backInputCSS=document.getElementById('backInputCSS')
            backInputCSS.style.display = "none"; 
            //不显示“重新生成”按钮
            var reRenderCSS=document.getElementById('reRenderCSS')
            reRenderCSS.style.display = "none"; 
            //不显示“下载”按钮
            var dwnbtn = document.getElementById('dwnbtn');
            dwnbtn.style.display = "none";
            break;
          default:
            backgroundImage = 'bk.png';
            break;
        }
    }
</script>

<!-- 手写部分 -->
<script>
    var canvas = document.getElementById('canvas');
    var ctx = canvas.getContext('2d');
    var isDraw = false; //定义变量控制画笔是否可用
    var movePos;         //定义变量存放初始画笔开始位置
    var linWidth = 10;
    var linColor = 'white';
    ctx.lineCap = "round";
    ctx.lineJoin = "round";
    var lastButtonDownTime
    var timeoutId=null;

    //清除
    function clearDraw(){
        console.log("一律清除")
        ctx.clearRect(-canvas.width, -canvas.height, canvas.width * 2, canvas.height * 2);
    }

    function writeOnload(){
        phase=1
        console.log("进入第一阶段，手写")

        checkPhase()
        //清空画布
        clearDraw()
        //重设原点
        ctx.translate(-PO.x,-PO.y)
        console.log("重新设置了原点",PO)
        //清空选择笔画
        chosenStrokes=[]

        //触摸摸下
        canvas.ontouchstart = function(e){
            // console.log("触摸按下")
            isDraw = true;
            movePos = getPos(e.changedTouches[0].clientX,e.changedTouches[0].clientY);
            // console.log("触摸的位置",movePos)
            touchDrawing(e);
        }
        //触摸移动
        canvas.ontouchmove = function(e){
            // console.log("触摸拖动")
            touchDrawing(e);
        }
        //停止触摸
        canvas.ontouchend = function(e){
            // console.log("触摸停止")
            if(phase==1){
                isDraw = false;
                if (timeoutId === null) {
                    timeoutId = setTimeout(writeOver, 2500);
                } else {
                    clearTimeout(timeoutId);
                    timeoutId = setTimeout(writeOver, 2500);
                }
            }
        }
        //摸出区域
        canvas.ontouchcancel =function(e){
            isDraw = false;
        }
        //鼠标点下
        canvas.onmousedown = function(e){
            // 阻止默认事件
            e.preventDefault();
            // console.log("鼠标按下")
            isDraw = true;
            movePos = getPos(e.clientX,e.clientY);
            // console.log("鼠标按下movePos",movePos)
            // console.log("鼠标按下isDraw",isDraw)
            ClickDrawing(e);
        }
        //鼠标移动
        canvas.onmousemove = function(e){
            // 阻止默认事件
            e.preventDefault();
            // console.log("鼠标移动isDraw",isDraw)
            ClickDrawing(e);
        }
        //鼠标松开
        canvas.onmouseup = function(e){
            // 阻止默认事件
            e.preventDefault();
            // console.log("鼠标松开isDraw0",isDraw)
            isDraw = false;
            if(phase==1){
                if (timeoutId === null) {
                    timeoutId = setTimeout(writeOver, 3000);
                } else {
                    clearTimeout(timeoutId);
                    timeoutId = setTimeout(writeOver, 3000);
                }
            }
        }
        //鼠标离开
        canvas.onmouseout =function(e){
            // console.log("鼠标离开isDraw",isDraw)
            isDraw = false;
        }
    
    }
    
    //获取鼠标相对与canvas位置
    function getPos(x,y){
        var box = canvas.getBoundingClientRect();
        return {x: x-box.left,y: y-box.top};
    };

    //触摸画笔
    function touchDrawing(touchEvent){
        if(isDraw){
            var position = getPos(touchEvent.changedTouches[0].clientX,touchEvent.changedTouches[0].clientY);
            ctx.strokeStyle = linColor;
            ctx.lineWidth = linWidth;
            ctx.save();
            ctx.beginPath();
            ctx.moveTo(movePos.x,movePos.y);
            ctx.lineTo(position.x,position.y);
            ctx.stroke();
            movePos = position;
            ctx.restore();
        }
    }
    
    //鼠标画笔
    function ClickDrawing(clickEvent){
        if(isDraw){
            var position = getPos(clickEvent.clientX,clickEvent.clientY);
            ctx.strokeStyle = linColor;
            ctx.lineWidth = linWidth;
            ctx.save();
            ctx.beginPath();
            ctx.moveTo(movePos.x,movePos.y);
            ctx.lineTo(position.x,position.y);
            ctx.stroke();
            movePos = position;
            ctx.restore();
        }
    }
    
    //书写完毕
    async function writeOver(){
        console.log('2秒钟没有点击，执行writeOver函数');
        const image = new Image();
        image.src = canvas.toDataURL('image/png');
        // console.log(image.src)
        timeoutId=null
        phase=2 //为避免两次发送请求，这里马上赋值为2

        await axios({
            method: 'POST',
            url: '/recognize',
            data: {
                "data":image.src,
            }
        })
        .then(res => {
            console.log("等待识别函数执行完毕",res.data.character)
            isDraw=false
            clearDraw()
            showOnload(res.data.character)
        }, error => {
            console.log('识别出现错误', error.message)
        })
    }
</script>

<!-- 选择部分 -->
<script>
    var chosenStrokes=[];   //用以记录都选中了笔画的哪几笔

    var svgPath=''
    var imgH, imgW, beginX, beginY;
    var rotate = 0;
    var scale = 1;
    //这里用改变坐标原点的方式来画图，让坐标原点始终在图片的中心


    var initImgW = 400;
    var initImgH = 400;
    var chosenColor;
    var chosenStrokeIndex;
    var img = new Image();
    var PO = { x: 0, y: 0 };
    var oldInputEng='';
    var oldBase64='';

    function backDraw(){
        console.log("从选择笔画返回重写")
        //不显示“重写”按钮
        var backDrawCSS=document.getElementById('backDrawCSS')
        backDrawCSS.style.display="none"
        //不显示“选择完毕”按钮
        var selectbtn = document.getElementById('selectbtn');
        selectbtn.style.display = "none";
        phase=1
        writeOnload()
    }

    function showOnload(uni){
        console.log("进入第二阶段：选择")
        phase=2
        checkPhase()

        initImgH=canvasH*0.6
        initImgW=canvasH*0.6

        svgPath='./svgs-still/'+uni+'-still.svg'
        img.src = svgPath;
        img.onload = function() {
            imgH=initImgW
            imgW=initImgH
            //记录一下canvas原点  为图片的中心点,因为旋转图标在外面，初始化改变一下位置，离边远一点
            PO = { x:canvasW/2, y:canvasH/2 };
            //改变画布的中心点
            ctx.translate(PO.x, PO.y);
            drawSVG();
        }

        //重新定义事件
        canvas.ontouchcancel=null
        canvas.ontouchstart=null
        canvas.ontouchend=null
        canvas.ontouchmove=null

        //读取画布上有鼠标被按下，实时更新位置显示并判定是否拖动
        canvas.onmousedown=async function(e){
            //e.offsetX是鼠标点击到canvas边的位置
            beginX = e.offsetX;
            beginY = e.offsetY;
            //把点击的win坐标转为canvas坐标
            var Cp = convertCoordinate(beginX, beginY)
            let imageData = ctx.getImageData(e.layerX, e.layerY, 1, 1)
            
            //print color
            let rectColor = 'rgb(' + imageData.data[0] + ', ' + imageData.data[1] + ',' + imageData.data[2] + ')'
            chosenColor = '#' + ("0" + imageData.data[0].toString(16)).substr(-2).toUpperCase()
                              + ("0" + imageData.data[1].toString(16)).substr(-2).toUpperCase()
                              + ("0" + imageData.data[2].toString(16)).substr(-2).toUpperCase()   // 转换为16进制
            console.log(rectColor)

            var x=await fun(svgPath)
        }
    }

    //画图
    function drawSVG(){
        //先清除画布，清除两倍的画布，因为要改变坐标原点，只有这样才能不管原点在哪里都能完全清除画布
        ctx.clearRect(-canvas.width, -canvas.height, canvas.width * 2, canvas.height * 2);
        //画图片，因为原点在图片的中心点，所以每次画图只需要从图片的负一半坐标开始画，就能看到我们想要的效果
        ctx.drawImage(img, -imgW / 2, -imgH / 2, imgW, imgH);
    }

    //window屏幕坐标转化为canvas坐标
    convertCoordinate = function(x, y) {
        //在屏幕坐标系中，相对canvas坐标系原点PO的偏移,所以要减去canvas坐标原点
        x = x - PO.x;
        y = y - PO.y;
        return { x: x, y: y }
    }
    

    async function fun(svgPath1){
        return new Promise((resolve, reject) => {
            var xhr = new XMLHttpRequest();
            var svgContent = '';    //记录svg文件内容
            xhr.onreadystatechange = function () {
                if (xhr.readyState === 0){
                    // console.log("state为0")
                }if (xhr.readyState === 1){
                    // console.log("state为1")
                }if (xhr.readyState === 2){
                    // console.log("state为2")
                }if (xhr.readyState === 3){
                    // console.log("state为3")
                }
                if (xhr.readyState === 4 && xhr.status === 200) {
                    // 当读取状态为4且响应状态为200时，使用responseText属性获取响应内容
                    svgContent = xhr.responseText;
                    var parser = new DOMParser();
                    var doc = parser.parseFromString(svgContent, "text/html");
                    var strokeStyle = doc.getElementsByTagName('style')[0].innerHTML;   //获取style标签下的全部内容
                    var strokes = strokeStyle.split("\n");  //将style下的样式按行分开
                    //获取点击的是哪一个笔画，存入i中
                    var i=NaN;
                    for(str of strokes){
                        var index=str.indexOf(chosenColor)
                        if(index!=-1){  //找到是哪一笔了
                            var sliceStart = str.indexOf(".stroke") + 7;    // 7 是 ".stroke " 的长度
                            var sliceEnd = str.indexOf(" ", sliceStart);
                            i=parseInt(str.substring(sliceStart, sliceEnd).trim());
                            chosenStrokeIndex=i;
                            break
                        }
                    }

                    if(i==i){   //若i为NaN，不进行下载
                        if(!chosenStrokes.includes(i))
                            chosenStrokes.push(i)
                    }

                    fetch(svgPath)
                    .then(response => response.text())
                    .then(data => {
                        var svgDoc_leave = document.createElement("div");
                        svgDoc_leave.innerHTML=data;
                        var paths = svgDoc_leave.getElementsByTagName("path");
                        var strokeNum=paths.length; //该字的笔画数目
                        for (var _i = 1; _i <= strokeNum; _i++) {
                            var elements = svgDoc_leave.querySelectorAll(".stroke"+_i);
                            if(chosenStrokes.includes(_i))
                                elements[0].style.fill = "pink"; // 将笔画颜色设置为粉色
                        }
                        // 保存修改后的SVG文件（下载）
                        var modifiedSVG1 = svgDoc_leave.innerHTML;
                        // 使用 FileSaver.js 或其他方法来保存 modifiedSVG 到你的计算机
                        // 创建一个Blob对象来保存修改后的SVG文件内容
                        var blob1 = new Blob([modifiedSVG1], { type: "image/svg+xml" });
                        //清空画布并把新图显示在画布上
                        const img = new Image();
                        img.src = URL.createObjectURL(blob1);
                        img.onload = () => {
                            const ctx = canvas.getContext('2d');
                            ctx.clearRect(-canvas.width, -canvas.height, canvas.width * 2, canvas.height * 2);
                            ctx.drawImage(img, -imgW / 2, -imgH / 2, imgW, imgH);
                        };
                    })
                    resolve(i)
                }
            };
            xhr.open("GET", svgPath1, true);
            xhr.send();
        })   
        }

    //点击选择完毕按钮
    function slectedOver(){
        console.log("进入第三阶段：输入标签")
        phase=3
        checkPhase()

        console.log("重画字的位置")
        ctx.translate(-PO.x,-PO.y)
        PO={x:canvasW*7/23,y:canvasH* 4/14} 
        console.log(PO)
        console.log("当前画布长款",canvasW,canvasH)
        ctx.translate(PO.x,PO.y)
        imgW=imgW*0.6
        imgH=imgH*0.6

        fetch(svgPath)
        .then(response => response.text())
        .then(data => {
            //
            // 深拷贝
            //
            let dataStr = JSON.stringify(data);
            let deepCopy = JSON.parse(dataStr);
            deepCopy = JSON.parse(JSON.stringify(deepCopy));
            
            // 创建一个虚拟元素来解析SVG
            var svgDoc_leave = document.createElement("div");
            svgDoc_leave.innerHTML=deepCopy;
            //
            // 选中了的我直接删除算了
            //
            var paths = svgDoc_leave.getElementsByTagName("path");
            var strokeNum=paths.length
            
            //我去，chatgpt真的好牛，删除会改变下标，我直接从后往前就好了
            for (var i = strokeNum - 1; i >= 0; i--) {
                // 获取指定下标的路径并删除
                if(chosenStrokes.includes(i+1)){
                    paths[i].remove();
                }
                // else{
                //     var elements = svgDoc_leave.querySelectorAll(".stroke"+(i+1));
                //     elements[0].style.fill = "black"; // 将笔画颜色设置为黑
                // }
            }

            // 保存修改后的SVG文件（下载）
            var modifiedSVG1 = svgDoc_leave.innerHTML;
            // 使用 FileSaver.js 或其他方法来保存 modifiedSVG 到你的计算机
            // 创建一个Blob对象来保存修改后的SVG文件内容
            var blob1 = new Blob([modifiedSVG1], { type: "image/svg+xml" });
            //清空画布并把新图显示在画布上

            img.src = URL.createObjectURL(blob1);
            img.onload = () => {
                const ctx = canvas.getContext('2d');
                ctx.clearRect(-canvas.width, -canvas.height, canvas.width * 2, canvas.height * 2);
                ctx.drawImage(img, -imgW / 2, -imgH / 2, imgW, imgH);
            };

            //
            // 2. 出现选择框
            //
            clearDraw()
            showInput()
        })
    }

    //展示输入框
    function showInput(){
        const inputBox = document.getElementById("container");
        // 将输入框显示出来
        inputBox.style.display = "block"

        // 设置输入框的位置为居中
        const inputBoxRect = inputBox.getBoundingClientRect();
        const offsetX = canvasW * 970/2300
        const offsetY = canvasH / 2 - inputBoxRect.height / 2;
        inputBox.style.left = offsetX + "px";
        inputBox.style.top = offsetY + "px";
    }

    // 隐藏输入框
    async function hideInput() {
        const inputBox = document.getElementById("container");
        var inputEng=inputBox.querySelector("input").value
        await axios({
            method: 'POST',
            url: '/translate',
            data: {
                "text":inputBox.querySelector("input").value,
            }
        })
        .then(res => {
            console.log("翻译完毕",res)
            inputEng=res.data.translation
        })
        .catch(error => {
            console.log('翻译出现错误', error.message)
        })

        console.log("你输入的英文是",inputEng)
        pre_render(inputEng)
        
        // 将输入框隐藏起来
        inputBox.style.display = "none";
        // 清空输入框的内容
        inputBox.querySelector("input").value = "";
    }


    async function pre_render(inputEng){
        fetch(svgPath)
        .then(response => response.text())
        .then(data => {
            var svgDoc_send = document.createElement("div");
            svgDoc_send.innerHTML=data;

            //
            // 3. 将选中的笔画挑出来转为png的base64编码
            //
            var paths = svgDoc_send.getElementsByTagName("path");
            var strokeNum=paths.length

            //我去，chatgpt真的好牛，删除会改变下标，我直接从后往前就好了
            for(var i=strokeNum - 1;i>=0;i--){
                if(!chosenStrokes.includes(i+1))
                    paths[i].remove();
            }
            var modifiedSVG = svgDoc_send.innerHTML;

            // 获取 SVG 根节点
            var svgRoot = svgDoc_send.firstChild;
            // 创建一个新的 Image 对象
            var iiimggg = new Image();
            // 将 SVG 转换为图片
            iiimggg.src = 'data:image/svg+xml;base64,' + window.btoa(unescape(encodeURIComponent(modifiedSVG)));
            // 当 SVG 转化为图片时触发
            iiimggg.onload = async function() {
                // 创建一个 Canvas 元素
                var canvas1 = document.createElement('canvas');
                canvas1.width = iiimggg.width;
                canvas1.height = iiimggg.height;

                // 在 Canvas 上绘制 SVG
                var ctx1 = canvas1.getContext('2d');
                ctx1.drawImage(iiimggg, 0, 0);
                // 将 Canvas 转换为 base64 编码的图片
                var base64Image = canvas1.toDataURL();

                await render(inputEng,base64Image)

                oldInputEng=inputEng    //记录，方便回传
                oldBase64=base64Image   //记录
            };
        })
    }

    async function render(inputEng,base64Image){
        console.log("base64待渲染",base64Image)
        await axios({
            method: 'POST',
            url: '/render',
            data: {
                "data":base64Image,
                "prompt":"{" + inputEng + "}"
            }
        })
        .then(res => {
            console.log("等待渲染完毕",res)
            //最后衔接组装部分
            assembleOnload(res.data)
        }, error => {
            console.log('渲染出现错误', error.message)
        })
    }
</script>

<!-- 移动部分 -->
<script>
    var img0 = new Image();
    var canMove=true;
    var canScale=true;
    var lastX,lastY,lastDoubleTouchDistance,lastDoubleTouchScale;
    var img0H,img0W,initImg0H,initImg0H;


    function assembleOnload(data){
        console.log("进入第四阶段：移动")
        phase=4
        checkPhase()

        clearDraw()
        ctx.translate(-PO.x,-PO.y)
        PO={ x:canvasW/2, y:canvasH/2 };
        ctx.translate(PO.x,PO.y)

        //画img
        new Promise((resolve, reject) => {
            fetch(svgPath)
            .then(response => response.text())
            .then(data => {
                console.log("开始装载img")
                var svgDoc_leave = document.createElement("div");
                svgDoc_leave.innerHTML=data;
                var paths = svgDoc_leave.getElementsByTagName("path");
                var strokeNum=paths.length
                
                //我去，chatgpt真的好牛，删除会改变下标，我直接从后往前就好了
                for (var i = strokeNum - 1; i >= 0; i--) {
                    // 获取指定下标的路径并删除
                    if(chosenStrokes.includes(i+1)){
                        paths[i].remove();
                    }
                    else{
                        var elements = svgDoc_leave.querySelectorAll(".stroke"+(i+1));
                        elements[0].style.fill = "black"; // 将笔画颜色设置为黑
                    }
                }

                // 保存修改后的SVG文件（下载）
                var modifiedSVG1 = svgDoc_leave.innerHTML;
                // 使用 FileSaver.js 或其他方法来保存 modifiedSVG 到你的计算机
                // 创建一个Blob对象来保存修改后的SVG文件内容
                var blob1 = new Blob([modifiedSVG1], { type: "image/svg+xml" });
                //清空画布并把新图显示在画布上

                img.src = URL.createObjectURL(blob1);
                console.log("装载好了")
                img.onload = () => {
                    ctx.drawImage(img,-initImgW/2,-initImgH/2,initImgW,initImgH)
                    resolve()
                };
            })
        })
        console.log("装载img完毕，开始装载img0")
        //画img0
        img0.src = data.base64;
        img0.onload = function() {
            img0H=data.height
            img0W=data.width
            initImg0H=img0H
            initImg0W=img0W
            //画图片，因为原点在图片的中心点，所以每次画图只需要从图片的负一半坐标开始画，就能看到我们想要的效果
            ctx.drawImage(img0, -img0W / 2, -img0H / 2, img0W, img0H);
        }

        //重新定义事件
        //鼠标选中图片
        clickImg0 = function(x, y) {
            //找到图片的最小值和最大值，因为画图是从-imgW / 2开始的，那么这就是图片占据的位置的最小值，最大值是imgW / 2,y轴同理
            if(-img0W / 2 < x && x < img0W / 2 && -img0H / 2 < y && y < img0H / 2){
                return true;
            }
            return false
        }
        //鼠标点击+鼠标移动
        canvas.onmousedown=async function(e){
            //e.offsetX是鼠标点击到canvas边的位置
            lastX = e.offsetX;
            lastY = e.offsetY;
            //鼠标点击时的相对坐标
            var Cp = convertCoordinate(lastX, lastY)
            canMove=clickImg0(Cp.x, Cp.y)

            //将图片边缘描黑
            canvas.onmousemove = (e) => {
                var x = e.offsetX;
                var y = e.offsetY;

                if(canMove){
                    //算出来移动的像素（每次都是减去上次的值）
                    var Mx = x - lastX;
                    var My = y - lastY;
                    //根据移动重新规划零点
                    PO = {x:Mx + PO.x, y:My + PO.y};
                    ctx.translate(Mx,My)
                    drawImg0(PO)
                    lastX = x;  //保存起来这次图画到了哪里
                    lastY = y;
                }
            }
            document.onmouseup = function() {
                canvas.onmousemove = null;
                document.onmouseup = null;
                canMove=false
            }
        }
        //鼠标滚轮
        canvas.onmousewheel = function(e) {
            // console.log("鼠标滚轮事件",e)
            var x = e.offsetX;
            var y = e.offsetY;
            var Cp = convertCoordinate(x, y)
            canScale=clickImg0(Cp.x, Cp.y)
            //同样需要判断如果鼠标在图片上，才允许缩放
            if (canScale) {
                console.log("鼠标滚轮滑动便大小")
                //e.wheelDelta如果大于0，证明鼠标是向上滚动，反之向下
                //使用*=错误的，因为你要是1.04->1.02，虽然是小，但是还是在增大!所以要用initImgW固定值！
                if (img0H<canvasH*2/3 && e.wheelDelta > 0) {
                    //放大的倍数可以根据实际情况定义，可以丝滑一点
                    scale += 0.02
                }
                if (img0W>100 && e.wheelDelta < 0) {
                    scale -= 0.02
                }
                img0W = scale * initImg0W;
                img0H = scale * initImg0H;
                drawImg0()
            }
        }

        //触摸选中图片
        touchImg0 = function(x, y) {
            //找到图片的最小值和最大值，因为画图是从-imgW / 2开始的，那么这就是图片占据的位置的最小值，最大值是imgW / 2,y轴同理
            if(-img0W / 2 < x && x < img0W / 2 && -img0H / 2 < y && y < img0H / 2){
                return true;
            }
            return false
        }
        //触摸摸下+触摸移动+双手放缩
        canvas.ontouchstart=function(e){
            e.preventDefault();
            if (e.touches.length === 2) {
                console.log("是双手触摸事件")
                
                // 如果用户使用两个手指触摸屏幕，则记录缩放的起点位置和缩放起始距离
                const touch1 = e.touches[0]
                const touch2 = e.touches[1];
                lastX = (touch1.clientX + touch2.clientX) / 2;
                lastY = (touch1.clientY + touch2.clientY) / 2;
                lastDoubleTouchDistance = Math.sqrt(
                    Math.pow(touch1.clientX - touch2.clientX, 2) + Math.pow(touch1.clientY - touch2.clientY, 2)
                );
                lastDoubleTouchScale = scale;
            }
            else{
                // console.log("触摸事件",e)
                var touch = e.changedTouches[0];
                lastX = touch.clientX;
                lastY = touch.clientY;
                var Cp = convertCoordinate(lastX, lastY)
                canMove=touchImg0(Cp.x,Cp.y)
            }
            
            // 如果正在拖拽
            canvas.ontouchmove=function(moveEvent){
                if (moveEvent.touches.length === 2) {
                    // 如果用户使用两个手指触摸屏幕，则计算距离比例并缩放图片
                    const curtouch1 = moveEvent.touches[0];
                    const curtouch2 = moveEvent.touches[1];
                    const distance = Math.sqrt(
                        Math.pow(curtouch1.clientX - curtouch2.clientX, 2) + Math.pow(curtouch1.clientY - curtouch2.clientY, 2)
                    );

                    // 获取画布的边界
                    var canvasRect = canvas.getBoundingClientRect();
                    var canvasLeft = canvasRect.left;
                    var canvasTop = canvasRect.top;
                    var canvasWidth = canvasRect.width;
                    var canvasHeight = canvasRect.height;

                    // 检查触摸点是否在画布上
                    if (!( (curtouch1.clientX > canvasLeft && curtouch1.clientX < canvasLeft + canvasWidth &&
                            curtouch1.clientY > canvasTop && curtouch1.clientY < canvasTop + canvasHeight) 
                           &&
                           (curtouch2.clientX > canvasLeft && curtouch2.clientX < canvasLeft + canvasWidth &&
                           curtouch2.clientY > canvasTop && curtouch2.clientY < canvasTop + canvasHeight)
                        ))
                        {
                            canMove=false   //不在画布上需取消
                            canScale = false;
                        }
                    else{
                        canMove=true
                        canScale=true
                    }


                    if(canScale){        
       

                        if (initImg0H * lastDoubleTouchScale * distance / lastDoubleTouchDistance < canvasH*2/3 
                            && 
                            initImg0W * lastDoubleTouchScale * distance / lastDoubleTouchDistance > 100) {
                            scale =lastDoubleTouchScale * distance / lastDoubleTouchDistance
                        }
                        img0W = scale * initImg0W;
                        img0H = scale * initImg0H;
 

                        // 计算移动距离
                        var deltaX = (curtouch1.clientX + curtouch2.clientX) / 2 - lastX;
                        var deltaY = (curtouch1.clientY + curtouch2.clientY) / 2 - lastY;

                        //根据移动重新规划零点
                        PO = {x:deltaX + PO.x, y:deltaY + PO.y};
                        //更新原点位置
                        ctx.translate(deltaX,deltaY)
                        drawImg0()
                        lastX = (curtouch1.clientX + curtouch2.clientX) / 2;
                        lastY = (curtouch1.clientY + curtouch2.clientY) / 2;
                    }        
                }
                else{
                    var moveTouch=moveEvent.changedTouches[0]
                    var currentX = moveTouch.clientX;
                    var currentY = moveTouch.clientY;

                    // 获取画布的边界
                    var canvasRect = canvas.getBoundingClientRect();
                    var canvasLeft = canvasRect.left;
                    var canvasTop = canvasRect.top;
                    var canvasWidth = canvasRect.width;
                    var canvasHeight = canvasRect.height;
                    // 检查触摸点是否在画布上
                    if (! (currentX > canvasLeft && currentX < canvasLeft + canvasWidth &&
                        currentY > canvasTop && currentY < canvasTop + canvasHeight) )
                        {
                            canMove=false   //不在画布上需取消
                            canScale = false;
                        }

                    if(canMove){
                        // console.log("触摸在了图片上，并正在移动",moveEvent)
                        // 计算移动距离
                        var deltaX = moveTouch.clientX - lastX;
                        var deltaY = moveTouch.clientY - lastY;

                        //根据移动重新规划零点
                        PO = {x:deltaX + PO.x, y:deltaY + PO.y};
                        ctx.translate(deltaX,deltaY)
                        drawImg0()
                        lastX = currentX;  //保存起来这次图画到了哪里
                        lastY = currentY;
                    }
                }
            }

            canvas.ontouchcancel=function(e){
                console.log("取消了")
                canvas.ontouchmove = null;
                document.ontouchend = null;
                canMove = false;
                canScale = false;
            }

            document.ontouchend = function() {
                console.log("离开了")
                canvas.ontouchmove = null;
                document.ontouchend = null;
                canMove = false;
                canScale = false;
            }
        }
        
    }

    function drawImg0(){
        ctx.clearRect(-canvas.width, -canvas.height, canvas.width * 2, canvas.height * 2);
        //指定中心为画布正中央
        ctx.translate(-PO.x,-PO.y);
        ctx.translate(canvasW/2,canvasH/2)
        ctx.drawImage(img,-initImgW/2,-initImgH/2,initImgW,initImgH)
        ctx.translate(-canvasW/2,-canvasH/2)
        ctx.translate(PO.x,PO.y);
        ctx.drawImage(img0, -img0W/2, -img0H/2, img0W, img0H);
    }
</script>

<!-- 保存部分 -->
<script>
    function download() {
        console.log("进入第五阶段：保存")
        phase=5
        checkPhase()

        QRcode()
    }

    function backInput(){
        console.log("从选择笔画返回重写")
        //不显示“下载”按钮
        var dwnbtn=document.getElementById('dwnbtn')
        dwnbtn.style.display="none"
        //不显示“重写”按钮
        var returnDrawCSS=document.getElementById('returnDrawCSS')
        returnDrawCSS.style.display="none"
        //不显示“首页”按钮
        var returnHomeCSS=document.getElementById('returnHomeCSS')
        returnHomeCSS.style.display="none"
        //不显示“重新输入标签”按钮
        var backInputCSS=document.getElementById('backInputCSS')
        backInputCSS.style.display = "none";  
        //不显示“重新生成”按钮
        var reRenderCSS=document.getElementById('reRenderCSS')
        reRenderCSS.style.display = "none"; 
        //不显示二维码
        var qr=document.getElementById("qrcode")
        qr.style.display = "none";
        qr.innerHTML='' //清空
        phase=3
        imgH=initImgH
        imgW=initImgW
        slectedOver()
    }

    function reRender(){
        //不显示“下载”按钮
        var dwnbtn=document.getElementById('dwnbtn')
        dwnbtn.style.display="none"
        //不显示“重新输入标签”按钮
        var backInputCSS=document.getElementById('backInputCSS')
        backInputCSS.style.display = "none";  
        //不显示“重新生成”按钮
        var reRenderCSS=document.getElementById('reRenderCSS')
        reRenderCSS.style.display = "none"; 
        phase=3
        imgH=initImgH
        imgW=initImgW

        clearDraw()
        ctx.translate(-PO.x,-PO.y);
        ctx.translate(canvasW/2,canvasH/2)
        ctx.drawImage(img,-initImgW/2,-initImgH/2,initImgW,initImgH)
        ctx.translate(-canvasW/2,-canvasH/2)
        ctx.translate(PO.x,PO.y);
        render(oldInputEng,oldBase64)
    }

    async function QRcode(){
        // 将图片转换为 Base64 编码
        var canvasBase64 = canvas.toDataURL('image/png');
        var base64Image=''
        var saveImg = new Image();
        // 将 SVG 转换为图片
        saveImg.src = canvasBase64
        // 当 SVG 转化为图片时触发
        await new Promise(resolve => {
            saveImg.onload = function() {
                console.log("801行")
                // 创建一个 Canvas 元素
                var canvas2 = document.createElement('canvas');
                canvas2.width = saveImg.width;
                canvas2.height = saveImg.height;

                // Canvas2打上白底再画上saveImg
                var ctx2 = canvas2.getContext('2d');
                ctx2.fillStyle="white"
                ctx2.fillRect(0,0,canvasW,canvasH);//填充画矩形
                ctx2.drawImage(saveImg, 0, 0);
                // 将 Canvas 转换为 base64 编码的图片
                base64Image = canvas2.toDataURL();
                console.log("812行")
                resolve()
            };                    
        })
        
        console.log("816行")

        //上传阿里云
        var url= ''
        console.log("817行")
        console.log("检查此时的base64Image",base64Image)
        await axios({
            method: 'POST',
            url: '/upload',
            data: {
                "data":base64Image,
            }
        })
        .then(res=>{
            console.log("上传成功",res)
            url=res.data.urls
        })
        .catch(error => {
            console.log('上传出现错误', error.message)
        })
        console.log("833行")
        
        // 将 Base64 编码生成二维码
        const qr=document.getElementById("qrcode")
        console.log("检查当前url",url)
        var qrcode = new QRCode(qr, {
          text: url,
          width: canvasH/4,
          height: canvasH/4,
          colorDark: "#000000",
          colorLight: "#ffffff",
          correctLevel: QRCode.CorrectLevel.H
        });
        qr.style.display = "block";

        final()
    }

    //最后的最后
    function final(){
        //将各种事件置空
        canvas.ontouchcancel=null
        canvas.ontouchstart=null
        canvas.ontouchend=null
        canvas.ontouchmove=null
        canvas.onmousedown=null
        canvas.onmouseleave=null
        canvas.onmouseup=null
        canvas.onmousemove=null
        canvas.onmousewheel=null
        canvas.onmouseover=null
        
        
        //将回退按钮显现
        const returnDrawCSS=document.getElementById("returnDrawCSS")
        returnDrawCSS.style.display = "block";
        const returnHomeCSS=document.getElementById("returnHomeCSS")
        returnHomeCSS.style.display = "block";
        var backInputCSS=document.getElementById('backInputCSS')
        backInputCSS.style.left="330px";
        backInputCSS.style.display = "block";  
    }

    function returnDraw(){
        console.log("重新绘制")
        //不显示“重写”按钮
        var returnDrawCSS=document.getElementById('returnDrawCSS')
        returnDrawCSS.style.display="none"
        //不显示“首页”按钮
        var returnHomeCSS=document.getElementById('returnHomeCSS')
        returnHomeCSS.style.display="none"
        //不显示“重新输入标签”按钮
        var backInputCSS=document.getElementById('backInputCSS')
        backInputCSS.style.display = "none";  
        //不显示二维码
        var qr=document.getElementById("qrcode")
        qr.style.display = "none";
        qr.innerHTML='' //清空
        phase=1
        writeOnload()
    }

    function returnHome(){
        console.log("重回主页")
        //不显示“首页”按钮
        var returnHomeCSS=document.getElementById('returnHomeCSS')
        returnHomeCSS.style.display="none"
        //不显示“重写”按钮
        var returnDrawCSS=document.getElementById('returnDrawCSS')
        returnDrawCSS.style.display="none"
        //不显示“重新输入标签”按钮
        var backInputCSS=document.getElementById('backInputCSS')
        backInputCSS.style.display = "none";  
        //不显示二维码
        var qr=document.getElementById("qrcode")
        qr.style.display = "none";
        qr.innerHTML='' //清空
        window.onload()
    }
</script>